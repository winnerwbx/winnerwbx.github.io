---
title: Share-谈高并发系统设计之——限流
date: 2019-07-22 10:38:29
tags: ARTS Share
categories:
- ARTS
- WEEK2
---

# Share

## 谈高并发系统设计之——限流

### 背景

对于高并发系统，请求是无限的，但是资源是有限的。有限的资源和无限的请求之间的矛盾就是高并发高可用系统面临的主要矛盾。如何在有限的资源内，最大程度地保障服务的高可用，也成为系统设计师和架构师重点关注的问题。

作为服务的提供方，无论是对外还是对内，我们首先需要对用户/调用方的流量进行预估，以确定服务容量以及承载能力。

但现实往往会发生许多意料之外的情况，如果用户/调用方对我们服务的瞬时请求激增，超过了我们的承载能力，我们该如何处理呢？

这也是高并发系统所面临的共性问题，有以下几种方式可以解决：

1. 限流
2. 缓存
3. 熔断
4. 降级

我们先来谈谈限流。

### 什么是限流？

来自 [WIKIPEDIA](https://en.wikipedia.org/wiki/Rate_limiting) 的定义:

> In computer networks, rate limiting is used to control the rate of traffic sent or received by a network interface controller and is used to prevent DoS attacks.

定义是关于网络设备的，我们也可以扩展到服务、接口，限流的目的是通过限速等措施，控制某一入口的流量，保护服务，防止服务被瞬时的大量请求击垮。

限流的适用场景很多，比如：

1. 用于秒杀、抢购等段时间大量请求并发的活动
2. 用于防止外部攻击，比如DoS
3. 用于合理分配资源，比如同时向多个调用方提供服务，防止某个调用方对接口大量请求导致占用过多CPU、线程池、内存等资源而影响了其他调用方的合理调用

### 限流如何做？

限流可以是单机的，也可以是集群（分布式）的。限流的维度可以是全局的，也可以具体到单机、调用方、甚至到接口维度，每个接口一个限流策略。

#### 单机限流

通常情况下，我们遇到的绝大部分的资源限制都是单机资源限制，使用单机限流就基本能够满足服务的限流需求。

常见的单机限流算法有如下几种：

1. 计数器
2. 令牌桶
3. 漏桶

##### 1. 计数器

原理很简单，使用一个原子变量作为计数器，代表目前已经接收到的请求数量

每有一个新的请求进来，该变量就自增1，假如我们的限流策略是每分钟1000个请求，如果在这一分钟内，变量达到了设置的上限（1000），则拒绝本次和后面的请求。

等到下一分钟，再把该变量置零，这样就实现了一个朴素的计数器限流算法。

等等，我们思考一下，**会有什么问题么？**

比如在0:59之前都没有请求过来，0:59突然来了1000个请求，根据规则，这1000个请求是可以放过的，等到1:00的时候，又同时来了1000个请求，由于计数器在此时已清零，所以这些请求也可以放过。

这就导致了在时间单位交界处，会有**突刺**的现象产生，有可能超过承受能力而击垮服务。

###### 怎么办？

可以采用**滑动窗口**的策略，还是用上面的场景：

```
1. 想象有一个滑动的窗口，窗口的时间为1分钟，限制窗口内最多1000个请求。

2. 窗口随着时间的增长持续往前滑动，在任意时刻过来的请求，都不会超过它所在窗口的限制。

3. 这种方法需要记录每次请求到达的时间，当有一个新的请求过来的时候，时间为T，计算请求在[T-1min,T)内的数量，如果小于等于1000，则放过，否则拒绝该请求。
```

使用这种办法，可以确保任意一个时间窗口内，流量都不会超过设置的限制，即可解决上面所说的**突刺**现象。

##### 2. 令牌桶

所谓**令牌桶**，顾名思义，需要定期往一个桶里装一定数量的令牌，每有一个请求过来，就从桶中获取一个令牌，如果能获取到，则放行，否则就等待或者丢弃。

用流程图表示如下：

![令牌桶](/images/bucket.png)

原理介绍了，实现起来还是有很多细节需要注意：

```
1. 比如1000个请求/分钟的限流策略，可以起一个线程，每分钟放1000个令牌到桶中。但是当请求量持续很高的时候，可能出现每分钟第一秒的时候就把1000个令牌消耗完了，导致后面的59秒都无法受理请求。

    解决的方法是让放令牌的操作尽量均匀，比如每60/1000秒放一个令牌，这样就可以使限流更加平滑。

2. 如果每分钟的令牌数远远大于请求数，令牌越攒越多，后面突然来了大量的请求一下子把积攒的令牌消耗完，也可能导致超过承载能力，怎么办？

    这就需要给令牌桶设置一个令牌上限，桶中令牌容量达到上限后，就不再加入新的令牌。
    
3. 我们可以拓展令牌的使用场景，比如对一些对资源消耗较大的请求，一次可以取多个令牌。

4. 可以把请求放到队列中，如果获取不到令牌，根据策略，可以阻塞等待，也可以丢弃。

```

令牌桶的优点是允许一定范围内的突发流量（不超过初始令牌容量），缺点是不如下面讲的漏桶算法平滑。

##### 3. 漏桶

漏桶的思想跟令牌桶有异曲同工之妙，只不过令牌桶是控制流入的速率，漏桶是控制留出的速率。

就像一个沙漏一样，无论多少突发请求过来，沙漏都以匀速向下流出，这样可以有效地控制突发的请求，保证匀速处理。流程图如下：

![漏桶](/images/loutong.png)

实现时，可以使用一个阻塞队列，所有请求都放入队列中，另外一个线程定时从该队列中取请求进行处理。

队列设置一个上限，如果请求数超过上线则丢弃。

漏桶的优势是能够保证出队请求的平滑性，缺点是可能无法应对一些突发流量。

#### 集群限流

讲完了单机限流，我们来看看集群（分布式）限流。

上面我们讲过，由于绝大部分的资源限制都是单机资源限制，单机限流就能够应对，那么什么时候需要做集群限流呢？

当集群使用了某些公共的资源，但这些公共资源有限，或者是需要对服务整体的流量进行限制，则需要做集群限流。

比如我们的服务依赖了某一第三方接口，该接口限制每分钟调用最多1000次，那么我们整个集群对该接口的请求就要限流到 1000/60 QPS，这时候单机限流恐怕没那么好使，就需要集群限流出场了。

##### 那么集群限流怎么做呢？

我们需要一个独立于我们服务之外的中心计数器，通过这个中心计数器的某一原子操作进行限流。

业界常见的方法是使用Redis的incr操作，首先根据限流的目标生成一个限流key，对于key设置过期时间，请求过来的时候首先读取该key的值，然后判断是否达到限流上限，假如没有达到，则调用该key的incr，执行+1操作，放过该请求；否则拒绝。

但是这个方法存在的问题是，读取->判断->执行+1操作，整体无法保证原子性。

有一种解决方法是通过Redis本身单线程的特性，将这三个操作整合在一个lua脚本里让Redis执行，就可以满足原子性。

我这里提供一种改进的无需使用lua脚本的方法，也可以供大家参考：

```
1. incr命令会在+1后返回当前的值，我们可以不用第一步的读取，直接对该key进行incr，根据返回的值是否大于限流值来判断是否进行限流。这个操作是原子的。

2. 对key设置过期时间，或者独立起一个线程对key进行定期的过期清理操作，以控制限流的时间。
```
